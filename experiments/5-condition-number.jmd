---
title: Example 5, Reducing Condition Numbers
weave_options:
    fig_ext: .svg
---

```{julia}
using ProximalDistanceAlgorithms
using Random, LinearAlgebra, MatrixDepot, Plots, DataFrames
include("plotutils.jl")
```

### Introduction

```{julia}
@doc reduce_cond
```

### Example

```{julia}
Random.seed!(5357)
M = matrixdepot("randcorr", 100)
cond(M)
```

```{julia}
F = svd(M)
F.S
```

#### Setup

```{julia}
function solve(c, F, algorithm, maxiters, penalty; mu = 1.0)
    # use Nesterov acceleration unless we're running ADMM
    accel = algorithm isa ADMM ? Val(:none) : Val(:nesterov)

    if algorithm isa SteepestDescent
        println("Steepest Descent + Nesterov")

        # track loss, penalized objective, gradient, etc.
        history = initialize_history(maxiters+1)

        # warm-up
        println(" | warm-up:")
        print(" | ")
        @time reduce_cond(algorithm, c, F,
            maxiters = 100,
            penalty = penalty,
            accel = accel,
            history = history)

        # real timing
        println(" | result:")
        print(" | ")
        history = initialize_history(maxiters+1)
        solution = @time reduce_cond(algorithm, c, F,
            maxiters = maxiters,
            penalty = penalty,
            accel = accel,
            history = history)
    else
        algstr = algorithm isa MM ? "MM + Nesterov" : "ADMM"
        println(algstr)

        # track loss, penalized objective, gradient, etc.
        history = initialize_history(maxiters+1)

        println(" | warm-up:")
        print(" | ")
        @time reduce_cond(algorithm, c, F,
            maxiters = 100,
            penalty = penalty,
            accel = accel,
            history = history,
            mu = mu)

        # real timing
        println(" | result:")
        print(" | ")
        history = initialize_history(maxiters+1)
        solution = @time reduce_cond(algorithm, c, F,
            maxiters = maxiters,
            penalty = penalty,
            accel = accel,
            history = history,
            mu = mu)
    end

    return solution, history
end
```

### Fusion matrix

```{julia}
c = 10.0
D = CondNumFM(c, size(M,1)); S = instantiate_fusion_matrix(D)
size(D)
```

```{julia}
unicodeplots()
spy(S)
```

```{julia}
spy(S'S)
```

#### Annealing schedules

```{julia}
penalty(œÅ, n) = min(1e6, 1.1 ^ floor(n/20))
gr(linewidth=2)

maxiters = 2000
xs = 1:maxiters
plot(xs, penalty.(1, xs), legend = nothing)
xlabel!("iteration")
ylabel!("rho")
```

#### MM

```{julia}
MM_sol, MM_trace = solve(c, F, MM(), maxiters, penalty)
plot_summary(MM_trace)
```

#### Steepest Descent

```{julia}
SD_sol, SD_trace = solve(c, F, SteepestDescent(), maxiters, penalty)
plot_summary(SD_trace)
```

#### ADMM

```{julia}
ADMM_sol, ADMM_trace = solve(c, F, ADMM(), maxiters, penalty, mu = 5e-1)
plot_summary(ADMM_trace)
```

### Quality of solutions

Quantify how much structure in the original matrix is preserved by checking signs of components.

$$
\mathrm{fidelity}(A, B)
=
100 \times \frac{\sum_{ij} 1 - |\mathrm{sign}(A_{ij}) - \mathrm{sign}(B_{ij})|}{p^{2}},
\qquad
A,B \in \mathbb{R}^{p \times p}
$$

```{julia}
df = table_summary(MM_trace, SD_trace, ADMM_trace, ls=false)

fidelity(A, B) = 100 * sum(1 .- abs.(sign.(A) .- sign.(B))) / length(B)

df[!, :fidelity] = [
    fidelity(MM_sol, M),
    fidelity(SD_sol, M),
    fidelity(ADMM_sol, M),
]

df
```

### Appendix

```{julia}
using Pkg; Pkg.status()
```

```{julia}
using InteractiveUtils; versioninfo()
```
