---
title: Convex Regression
author: Alfonso Landeros
---

```{julia; result = "hidden"}
using ProximalDistanceAlgorithms
using Random, LinearAlgebra, Plots, DataFrames, CSV, Statistics
gr(linewidth = 3, grid = false)

const EXAMPLEDIR = joinpath("experiments", "cvxreg")
const FIGURES    = joinpath(EXAMPLEDIR, "figures")
const BENCHMARKS = joinpath(EXAMPLEDIR, "benchmarks")
const LOGTYPES   = (MMLogger, SDLogger)
const ALGORITHMS = (MM(), SteepestDescent())

SAVEFIG = true
```

### Example 1: Euclidean norm

```{julia}
φ(x) = dot(x, x)    # function to estimate
d = 1               # number of covariates
n = 50              # number of samples
σ = 0.2             # standard deviation of perturbations

tag = "d=$(d)_n=$(n)_sigma=$(σ).pdf"

# create a problem instance
Random.seed!(1776)

y, y_truth, X = cvxreg_example(φ, d, n, σ)
y_scaled, X_scaled = mazumder_standardization(y, X)

figureA = plot(title = "simulated data")
plot!(X', y_truth, label = "truth")
scatter!(X', y, label = "observed")

figureB = plot(title = "after standardization")
plot!(X_scaled', y_truth / norm(y_truth), label = "truth")
scatter!(X_scaled', y_scaled, label = "observed")

figure = plot(figureA, figureB, xlabel = "x", ylabel = "phi(x)",)

SAVEFIG && savefig(figure, joinpath(FIGURES, "demo_"*tag))

figure
```

##### Proximal Distance

```{julia}
maxiters = 5*10^3
sample_rate = 100
ρ_init = 1.0

history = MMLogger(maxiters ÷ sample_rate, sample_rate)

θ, ξ = @time cvxreg_fit(MM(), y_scaled, X_scaled,
    maxiters = maxiters,
    ρ_init   = ρ_init,
    penalty  = slow_schedule,
    history  = history)

figure = plot(xlabel = "x", ylabel = "phi(x)", title = "original scale")
plot!(X_scaled', y_truth, label = "truth")
scatter!(X_scaled', y_scaled*norm(y), label = "observed")
scatter!(X_scaled', θ*norm(y), label = "fit")

SAVEFIG && savefig(figure, joinpath(FIGURES, "fit_mm_"*tag))

figure
```

```{julia}
figure = plot(history)

SAVEFIG && savefig(figure, joinpath(FIGURES, "log_mm_"*tag))

figure
```

##### Proximal Distance + Steepest Descent

```{julia}
maxiters = 5*10^3
sample_rate = 100
ρ_init = 1.0

history = SDLogger(maxiters ÷ sample_rate, sample_rate)

θ, ξ = @time cvxreg_fit(SteepestDescent(), y_scaled, X_scaled,
    maxiters = maxiters,
    ρ_init   = ρ_init,
    penalty  = slow_schedule,
    history  = history)

figure = plot(xlabel = "x", ylabel = "phi(x)", title = "original scale")
plot!(X_scaled', y_truth, label = "truth")
scatter!(X_scaled', y_scaled*norm(y), label = "observed")
scatter!(X_scaled', θ*norm(y), label = "fit")

SAVEFIG && savefig(figure, joinpath(FIGURES, "fit_sd_"*tag))

figure
```

```{julia}
figure = plot(history)

SAVEFIG && savefig(figure, joinpath(FIGURES, "log_sd_"*tag))

figure
```

### Benchmarks

```{julia}
# benchmark parameters
σ = 0.2
maxiters = 5*10^3
ρ_init = 1.0
sample_rate = 100
ntrials = 100

COVARIATES = (1,2,10)
OBSERVATIONS = (50, 100, 200, 500)

for (LogType, algorithm) in zip(LOGTYPES, ALGORITHMS)
    println("$(typeof(algorithm))")
    # store convergence history for each instance
    logs = Dict{Tuple{Int,Int},LogType}()

    # fields for DataFrame summary
    ncovariates = Int[]
    nsamples    = Int[]
    loss        = Float64[]
    objective   = Float64[]
    penalty     = Float64[]
    gradient    = Float64[]
    cpu_time    = Float64[]

    if algorithm isa MM
        prefix = "mm_"
    elseif algorithm isa SteepestDescent
        prefix = "sd_"
    else
        error("unknown algorithm option: $(algorithm)")
    end

    # make sure each algorithm sees the same problem
    Random.seed!(1776)

    for n in OBSERVATIONS, d in COVARIATES
        println("   (d, n) = ($(d), $(n))")
        # simulate data
        y, y_truth, X = cvxreg_example(φ, d, n, σ)

        # standardize according to mazumder
        y_scaled, X_scaled = mazumder_standardization(y, X)

        # solve the problem and record CPU time
        cpu_sample = zeros(ntrials)
        for trial in 1:ntrials
            history = LogType(maxiters ÷ sample_rate, sample_rate)

            tt = @elapsed cvxreg_fit(algorithm, y_scaled, X_scaled,
                maxiters = maxiters,
                ρ_init   = ρ_init,
                penalty  = slow_schedule,
                history  = history)

            cpu_sample[trial] = tt
        end

        # save the log and record entries for summary
        history = LogType(maxiters ÷ sample_rate, sample_rate)
        cvxreg_fit(algorithm, y_scaled, X_scaled,
            maxiters = maxiters,
            ρ_init   = ρ_init,
            penalty  = slow_schedule,
            history  = history)
        logs[(d,n)] = history

        push!(ncovariates, d)
        push!(nsamples, n)
        push!(loss, history.loss[end])
        push!(objective, history.objective[end])
        push!(penalty, history.penalty[end])
        push!(gradient, history.g[end])
        push!(cpu_time, mean(cpu_sample))
    end

    # save convergence histories to disk
    if SAVEFIG
        for ((d,n), history) in logs
            problem = "d=$(d)_n=$(n)_sigma=$(σ).pdf"
            figure = plot(history)
            savefig(figure, joinpath(FIGURES, prefix*problem))
        end
    end

    # table summary
    df = DataFrame(
        d = ncovariates,
        n = nsamples,
        cpu_time = cpu_time,
        loss = loss,
        objective = objective,
        penalty = penalty,
        gradient = gradient,
    )

    # save table to disk
    CSV.write(joinpath(BENCHMARKS, prefix*"benchmarks.dat"), df)
end
```

##### Proximal Distance

```{julia}
CSV.read(joinpath(BENCHMARKS, "mm_benchmarks.dat"))
```

##### Proximal Distance + Steepest Descent

```{julia}
CSV.read(joinpath(BENCHMARKS, "sd_benchmarks.dat"))
```

```{julia}
using Convex, Gurobi#, MosekTools

# benchmark parameters
σ = 0.2
maxiters = 5*10^3
Random.seed!(1776)

for n in (50, 100, 200), d in (1, 2, 10)
    # simulate data
    y, y_truth, X = cvxreg_example(φ, d, n, σ)

    # standardize according to mazumder
    y_scaled, X_scaled = mazumder_standardization(y, X)

    # solve with Gurobi
    _, _, problem = cvxreg_fit(BlackBox(), y_scaled, X_scaled)
    open(joinpath("tables", "cvxreg",
        "gurobi", "d=$(d)_n=$(n)_sigma=$(σ).dat"), "w") do file
        #
        run() = solve!(problem, GurobiSolver())
        redirect_stdout(run, file)
    end

    # solve with Mosek
    # _, _, problem = cvxreg_fit(BlackBox(), y_scaled, X_scaled)
    # open(joinpath("tables", "cvxreg_mosek_d=$(d)_n=$(n).dat"), "w") do file
    #     run() = solve!(problem, Mosek.Optimizer())
    #     redirect_stdout(run, file)
    # end
end
```
