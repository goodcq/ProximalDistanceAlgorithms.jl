---
title: Convex clustering with a greedy search
options:
    fig_ext: .svg
---

```{julia}
using ProximalDistanceAlgorithms
using Statistics, Plots, Random, Distances
```

### Example: $k$ = 3 unbalanced clusters

We will use the penalty $\rho(n) = \mathrm{max}\{10^{6}, 1.5^{\lfloor{n/50}\rfloor}\}$ throughout the following examples.

```{julia}
penalty(ρ, iteration) = min(1e6, iteration % 50 == 0 ? 1.5 * ρ : ρ)
```

```{julia}
Random.seed!(5357)

# simulate three clusters, each with 10 members
centroid = [[0.0, 0.0], [2.0, 2.0], [1.8, 0.5]]
nclass = [50, 20, 30]

# true centroid assignment
Y1 = repeat(centroid[1], outer = (1, nclass[1]))
Y2 = repeat(centroid[2], outer = (1, nclass[2]))
Y3 = repeat(centroid[3], outer = (1, nclass[3]))
Y = [Y1 Y2 Y3]

# simulated data
X1 = gaussian_cluster(centroid[1], nclass[1])
X2 = gaussian_cluster(centroid[2], nclass[2])
X3 = gaussian_cluster(centroid[3], nclass[3])
X = [X1 X2 X3]
d, n = size(X)

xs = X[1, :]
ys = X[2, :]

fig = scatter(xs, ys, xlabel = "feature1", ylabel = "feature2")
title!("3 clusters, $(n) samples", legend = false)
display(fig)
```

```{julia}
function plot_clustering(U, X, ν)
    adjacency, class, nclasses = assign_classes(U)

    xs = X[1, :]
    ys = X[2, :]

    figure_clustering = scatter(
        title  = "classes = $(nclasses) (nu = $(ν))",
        xlabel = "feature1",
        ylabel = "feature2",
        legend = nothing)

    for i in 1:nclasses
        I = findall(isequal(i), class)
        group_xs = xs[I]
        group_ys = ys[I]
        xmean = mean(group_xs)
        ymean = mean(group_ys)
        scatter!(group_xs, group_ys, label = "class $(i)")
        scatter!((xmean, ymean), markershape = :star, markersize = 10, label = nothing)
    end

    display(figure_clustering)
end
```

##### Solution path (no weights)

The search heuristic is as follows:

1. Let $\nu_{\mathrm{max}} = \binom{n}{2}$ and set $\nu = \nu_{\mathrm{max}}$, the putative number of violations in constraints $\boldsymbol{u}_{i} = \boldsymbol{u}_{j}$.

2. Solve the clustering problem using parameter $\nu$ in the sparse projection.

3. Save the solution $\boldsymbol{U}(\nu)$ and $\nu$.

4. Set $s$ equal to the number of satisfied constraints in $\boldsymbol{U}(\nu)$.

5. Set $\nu = \min\{\nu - 1, \nu_{\mathrm{max}} - s - 1\}$.

6. If $\nu \ge 0$, go to (2).

```{julia}
maxiters = 2 * 10^3
W = ones(n, n)

solution_path = @time convex_clustering_path(SteepestDescent(), W, X,
    maxiters = maxiters,
    penalty = penalty,
    accel = Val(:nesterov))

path_length = length(solution_path.ν)
search_space = binomial(n, 2) + 1

println("""
number of values checked: $(path_length)
size of search space:     $(search_space)
% of space covered:       $(100 * path_length / search_space)
""")
```

##### A few examples of the clusterings

Colors indicate distinct classes, stars indicate centroids.

**Early (many clusters)**

```{julia}
ix = 1
plot_clustering(solution_path.U[ix], X, solution_path.ν[ix])
```

**Halfway**

```{julia}
ix = path_length ÷ 2
plot_clustering(solution_path.U[ix], X, solution_path.ν[ix])
```

**Late (few clusters)**

```{julia}
ix = path_length - 10
plot_clustering(solution_path.U[ix], X, solution_path.ν[ix])
```

```{julia}
ix = path_length - 1
plot_clustering(solution_path.U[ix], X, solution_path.ν[ix])
```

```{julia}
ix = path_length
plot_clustering(solution_path.U[ix], X, solution_path.ν[ix])
```

##### Appendix

```{julia}
using InteractiveUtils; versioninfo()
```

```{julia}
using Pkg; Pkg.status()
```
