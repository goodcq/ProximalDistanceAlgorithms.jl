---
title: Projecting onto a simplex
---

```{julia; results = "hidden"}
# shorthand for AbstractVector
AVec = AbstractVector

"""
Project `x` onto the regular simplex of size `a` based on the splitting value `τ`, storing the output inside `y`.
"""
function project_simplex(x::AVec, a::Real = 1.0; alg::Function = algorithm1)
    # map elements onto non-negative orthant
    y = abs.(x)

    # determine the splitting value, τ
    τ = alg(y, a)

    # compute the projection based on KKT conditions
    for k in eachindex(x)
        y[k] = max(0, x[k] - τ)
    end

    return y
end
```

### Algorithm 1: A sorting method

```{julia; results = "hidden"}
function algorithm1(y::AVec, a::Real)
    # sort elements in decreasing order using quicksort
    sort!(y, rev = true)

    # initialization
    n = length(y)
    j = 1           # cardinality of the index set, I
    τ = y[j] - a    # initialize the splitting element, τ

    # add the largest elements until τ satisfies the splitting condition:
    #   y[i] - τ <= 0, for i not in the index set I, and
    #   y[i] - τ > 0,  for i in the index set I
    while j < n && (y[j] ≤ τ || y[j+1] > τ)
        # update τ and the cardinality of I
        τ = (j*τ + y[j+1]) / (j+1)
        j += 1
    end

    return τ
end
```

### Algorithm 2: A heap method

```{julia; results = "hidden"}
function maxheap!(y::AVec, offset::Integer = 0)
    n = length(y) - offset  # size of the heap
    levels = n >> 1         # number of levels

    # build the heap using a bottom-up approach
    for root in levels:-1:1
        push_down_max!(y, n, root)
    end

    return y
end

parent(i) = i >> 1
lchild(i) = 2*i
rchild(i) = 2*i + 1

swap!(h, i, j) = begin h[i], h[j] = h[j], h[i]; return nothing end

function push_down_max!(y::AVec, n::Integer, root::Integer)
    child = lchild(root)

    while child ≤ n # while root has a child
        # if the child has a larger sibling, point to the sibling
        if child + 1 ≤ n && y[child + 1] > y[child]
            child = child + 1
        end

        if y[child] > y[root]
            swap!(y, root, child)
        end

        root = child
        child = lchild(root)
    end

    return nothing
end
```

```{julia; results = "hidden"}
function algorithm2(y::AVec, a::Real)
    # build a max-order heap
    maxheap!(y)

    # initialization
    n = length(y)
    j = 1           # cardinality of the index set, I
    τ = y[j] - a    # initialize the splitting element, τ

    swap!(y, 1, n)              # put the largest element at the end
    push_down_max!(y, n-j, 1)   # and use entries 1:n-j for the next heap
    k = n                       # index of the previous largest element

    # add the largest elements until τ satisfies the splitting condition:
    #   y[i] - τ <= 0, for i not in the index set I, and
    #   y[i] - τ > 0,  for i in the index set I
    # here, y[k] is the previous element and y[1] is the next largest element
    while j < n && (y[k] ≤ τ || y[1] > τ)
        # update τ and the cardinality of I
        τ = (j*τ + y[1]) / (j+1)
        j += 1
        k -= 1
        swap!(y, 1, k)
        push_down_max!(y, n-j, 1)
    end

    return τ
end
```

## Tests

```{julia; results = "hidden"}
using Test

x = rand(10^6)
a = 10.0

y1 = project_simplex(x, a, alg = algorithm1)
y2 = project_simplex(x, a, alg = algorithm2)
```

```{julia}
@testset "Algorithm 1 (reference)" begin
    @test all(≥(0), y1)             # non-negativity
    @test sum(y1) ≈ a rtol = 1e-4   # convexity
end
```

```{julia}
@testset "Algorithm 2" begin
    @test all(≥(0), y1)             # non-negativity
    @test sum(y1) ≈ a rtol = 1e-4   # convexity
    @test y2 == y1
end
```

## Benchmarks

```{julia}
@time project_simplex(x, a, alg = algorithm1);
@time project_simplex(x, a, alg = algorithm2);
```

##### Appendix

```{julia}
using InteractiveUtils; versioninfo()
```

```{julia}
using Pkg; Pkg.status()
```
